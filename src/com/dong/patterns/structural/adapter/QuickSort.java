package com.dong.patterns.structural.adapter;
//
//
//  Generated by StarUML(tm) Java Add-In
//
//  @ Project : Adapter Pattern
//  @ File Name : QuickSort.java
//  @ Date : 2018/10/13
//  @ Author : dong
//  @ Description : 快速排序类，适配者 Adaptee
//




public class QuickSort {
    
    public int[] quickSort(int array[]) {
        sort(array, 0, array.length - 1);
        
        return array;
    }
    
    /*public void sort(int array[], int p, int r) {
        int q = 0;
        if(q < r) {
            q = partition(array, p, r);
            sort(array, p, q - 1);
            sort(array, q + 1, r);
        }
    }
    
    public int partition(int a[], int p, int r) {
        int x = a[r];
        int j = p - 1;
        for (int i = p; i <= r - 1; i++) {
            if(a[i] <= x) {
                j ++;
                swap(a, j, i);
            }
        }
        swap(a, j + 1, r);
        
        return j + 1;    
    }
    
    public void swap(int a[], int i, int j) {
        int t = a[i];
        a[i] = a[j];
        a[j] = t;
    }
    
    
    public static void main(String[] args) {
        QuickSort q = new QuickSort();
        int[] scores = {84, 76,50, 69, 90, 100, 60, 59};
        int[] arr = q.quickSort(scores);
        
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + ",");
        }
    }*/
    
    // 快速排序
    public void sort(int[] a,int low,int high){
        int start = low;
        int end = high;
        int key = a[low];
        
        
        while(end>start){
            //从后往前比较
            while(end>start&&a[end]>=key)  //如果没有比关键值小的，比较下一个，直到有比关键值小的交换位置，然后又从前往后比较
                end--;
            if(a[end]<=key){
                int temp = a[end];
                a[end] = a[start];
                a[start] = temp;
            }
            //从前往后比较
            while(end>start&&a[start]<=key)//如果没有比关键值大的，比较下一个，直到有比关键值大的交换位置
               start++;
            if(a[start]>=key){
                int temp = a[start];
                a[start] = a[end];
                a[end] = temp;
            }
        //此时第一次循环比较结束，关键值的位置已经确定了。左边的值都比关键值小，右边的值都比关键值大，但是两边的顺序还有可能是不一样的，进行下面的递归调用
        }
        //递归
        if(start>low) sort(a,low,start-1);//左边序列。第一个索引位置到关键值索引-1
        if(end<high) sort(a,end+1,high);//右边序列。从关键值索引+1到最后一个
    }
    
}
